use strict;
use warnings;

# filter a sample's outer clips in a stream 
# against a file of clipped junction reference nodes

# constants
use constant {
    SV_INDEX   => 0, # reference node file columns generated by R
    NODE       => 1,
    NODE_N     => 2,
    OTHER_NODE => 3,
    #===============
    CHROM => 0,
    SIDE  => 1,
    POS   => 2,
    #===============
    NODE_1 => 0, # node-level data
    CLIP_LEN_1 => 1,
    CLIP_SEQ_1 => 2,
    #---------------
    FLAG_1 => 3, # alignment-level data
    POS_1 => 4,
    MAPQ_1 => 5,
    CIGAR_1 => 6,
    SEQ_1 => 7,
    ALN_N_1 => 8,
    #---------------
    UMI_1 => 9,
    #===============
    NODE_CLASS => 10,
    #---------------
    JXN_TYPE => 11, # edge/junction-level data
    JXN_N => 12,
    #---------------
    MOL_ID => 13, # molecule-level information  
    IS_MERGED => 14,
    IS_DUPLEX => 15,
    STRAND_COUNT1 => 16,
    STRAND_COUNT2 => 17,
    MOL_CLASS => 18,
    MOL_STRAND => 19,
    IS_OUTER_CLIP1 => 20,
    IS_OUTER_CLIP2 => 21,
    TARGET_CLASS => 22, # converted by this script from molecule-outer-end to junction target class
    SHARED_PROPER => 23,
    #---------------
    OUT_POS_1 => 24,
    OUT_POS_2 => 25,
    #---------------
    CLIP_NODE_N => 26, # temporary value added by compile_nodes for our use, placed into jxnKey
    SAMPLE => 26       # added by this script to support sample-admixed SV finding
};

# working variables
my ($sample, $refNodesFile) = @ARGV;
my (%refNodes);
my @nullNode = (
    '*', # NODE
    0,   # CLIP_LEN
    '*', # CLIP_SEQ
    #---------------
    0,   # FLAG_
    0,   # POS
    0,   # MAPQ
    '*', # CIGAR
    '*', # SEQ
    0,   # ALN_N
    #---------------
    0,   # UMI
);  
my @samples = split(/\s+/, $ENV{SAMPLES});
my %samples = map { $samples[$_] => $_ + 1 } 0..$#samples;
my $sampleIndex = $samples{$sample};

# load the reference nodes (two per split/gap SV junction)
# the same node could possibly be claimed by more than one SV
open my $inH, "<", $refNodesFile or die "could not open: $!";
while (my $line = <$inH>){
    chomp $line;
    my @f = split("\t", $line);
    push @{$refNodes{$f[NODE]}}, [@f[SV_INDEX, NODE_N], $f[OTHER_NODE]];
}
close $inH;

# filter the outer clips and print matching clips into one-sided molecules
while (my $line = <STDIN>){
    chomp $line;    
    my @f = split("\t", $line);
    $refNodes{$f[NODE_1]} or next;
    my $alignedNodeOutPosI = $f[CLIP_NODE_N] == 1 ? OUT_POS_2 : OUT_POS_1; # outer position of the OTHER end of the molecule

    # assemble and print a complete molecule line from each outer clip node
    foreach my $svNode(@{$refNodes{$f[NODE_1]}}){
        my @f_ = @f; # copy clip since we will modify it below, i.e., prevent those changes from impacting the next SV
        my ($svIndex, $refNodeN, $clipNode) = @$svNode;
        my @clipSplitNode = split(":", $clipNode); # the presumptive node if the clip had been aligned
        my $multiplier = $clipSplitNode[SIDE] eq 'L' ? -1 : 1;
        my (@node1, @node2, @splitNode1, @splitNode2);

        # put outer-clipped alignment node into the same node position as the SV reference node
        # thus, we are creating the junction inferred by the match of the clipped and reference nodes
        if($refNodeN == 1){ 
            @node1 = @f_[NODE_1..UMI_1];
            @node2 = @nullNode;
            @splitNode1 = split(":", $f_[NODE_1]);
            @splitNode2 = @clipSplitNode; # adjust other node with just enough information for processing and plotting
            $f_[OUT_POS_1] = $f_[$alignedNodeOutPosI];
            $f_[OUT_POS_2] = $clipSplitNode[POS] + $multiplier * $f_[CLIP_LEN_1];   
        } else {
            @node1 = @nullNode;
            @node2 = @f_[NODE_1..UMI_1];
            @splitNode1 = @clipSplitNode;
            @splitNode2 = split(":", $f_[NODE_1]);
            $f_[OUT_POS_1] = $clipSplitNode[POS] + $multiplier * $f_[CLIP_LEN_1];   
            $f_[OUT_POS_2] = $f_[$alignedNodeOutPosI];
        }

        # print a molecule line consistent with call_svs.R
        print join("\t", 
            @node1, 
            @f_[NODE_CLASS..OUT_POS_2],
            $sample,
            @node2,
            0, # groupIndex, NA            
            @splitNode1, # chrom, side, pos
            @splitNode2,
            join(",", $node1[0], $node2[0]), # jxnName
            # join(":", $sampleIndex, @f_[MOL_ID, JXN_N]), # jxnKey
            join(":", $sampleIndex, @f_[MOL_ID, JXN_N, CLIP_NODE_N]), # jxnKey
            $svIndex, 
            join(":", $sampleIndex, $svIndex), # sampleSvIndex
            0, # AMBIGUOUS, NA
            0, # DOWNSAMPLED
            1, # N_COLLAPSED
            0 # IS_REFERENCE
        ), "\n";
    }
}
