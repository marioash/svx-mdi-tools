use strict;
use warnings;

# filter a sample's outer clips in a stream 
# against a file of clipped junction reference nodes

# constants
use constant {
    SV_INDEX => 0, # reference node file columns generated by R
    NODE     => 1,
    NODE_N   => 2,
    #===============
    NODE_1 => 0, # node-level data
    CLIP_LEN_1 => 1,
    CLIP_SEQ_1 => 2,
    #---------------
    FLAG_1 => 3, # alignment-level data
    POS_1 => 4,
    MAPQ_1 => 5,
    CIGAR_1 => 6,
    SEQ_1 => 7,
    ALN_N_1 => 8,
    #---------------
    UMI_1 => 9,
    #===============
    NODE_CLASS => 10,
    #---------------
    JXN_TYPE => 11, # edge/junction-level data
    JXN_N => 12,
    #---------------
    MOL_ID => 13, # molecule-level information  
    IS_MERGED => 14,
    IS_DUPLEX => 15,
    STRAND_COUNT1 => 16,
    STRAND_COUNT2 => 17,
    MOL_CLASS => 18,
    MOL_STRAND => 19,
    IS_OUTER_CLIP1 => 20,
    IS_OUTER_CLIP2 => 21,
    TARGET_CLASS => 22, # converted by this script from molecule-outer-end to junction target class
    SHARED_PROPER => 23,
    #---------------
    OUT_POS_1 => 24,
    OUT_POS_2 => 25,
    #---------------
    SAMPLE => 26 # added by this script to support sample-admixed SV finding
};

# working variables
my ($sample, $refNodesFile) = @ARGV;
my (%refNodes);
my @nullNode = (
    '*', # NODE
    0,   # CLIP_LEN
    '*', # CLIP_SEQ
    #---------------
    0,   # FLAG_
    0,   # POS
    0,   # MAPQ
    '*', # CIGAR
    '*', # SEQ
    0,   # ALN_N
    #---------------
    0,   # UMI
);
my @nullSplitNode = (
    0,   # CHROM_INDEX
    '*', # SIDE
    0,   # POS
);
my @samples = split(/\s+/, $ENV{SAMPLES});
my %samples = map { $samples[$_] => $_ + 1 } 0..$#samples;
my $sampleIndex = $samples{$sample};

# load the reference nodes
# the same node could possibly be claimed by more than one SV
open my $inH, "<", $refNodesFile or die "could not open: $!";
while (my $line = <$inH>){
    chomp $line;
    my @f = split("\t", $line);
    push @{$refNodes{$f[NODE]}}, [@f[SV_INDEX, NODE_N]];
}
close $inH;

# filter the outer clips
while (my $line = <STDIN>){
    chomp $line;    
    my @f = split("\t", $line);
    $refNodes{$f[NODE_1]} or next;

    # assemble and print a complete molecule line from each outer clip node
    foreach my $svNode(@{$refNodes{$f[NODE_1]}}){
        my (@node1, @node2, @splitNode1, @splitNode2);
        if($$svNode[1] == 1){ # put outer clip into the same node position as the SV reference node
            @node1 = @f[NODE_1..UMI_1];
            @node2 = @nullNode;
            @splitNode1 = split(":", $f[NODE_1]);
            @splitNode2 = @nullSplitNode;
        } else {
            @node1 = @nullNode;
            @node2 = @f[NODE_1..UMI_1];
            @splitNode1 = @nullSplitNode;
            @splitNode2 = split(":", $f[NODE_1]);
        }
        print join("\t", 
            @node1, 
            @f[NODE_CLASS..OUT_POS_2],
            $sample,
            @node2,
            0, # groupIndex, NA
            0, # AMBIGUOUS, NA
            1, # N_COLLAPSED
            join(",", $node1[0], $node2[0]), # jxnName
            join(":", $sampleIndex, @f[MOL_ID, JXN_N]), # jxnKey
            @splitNode1,
            @splitNode2,
            $$svNode[0], # svIndex
            join(":", $sampleIndex, $$svNode[0]), # sampleSvIndex
            0 # IS_REFERENCE
        ), "\n";
    }
}
