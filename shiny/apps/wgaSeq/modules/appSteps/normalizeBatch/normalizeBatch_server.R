#----------------------------------------------------------------------
# reactive components to generate interactive plots for visualizing 
# batch effect normalization in bin count data 
#----------------------------------------------------------------------

#----------------------------------------------------------------------
# BEGIN MODULE SERVER
#----------------------------------------------------------------------
normalizeBatchServer <- function(id, options, bookmark, locks) {
    moduleServer(id, function(input, output, session) {
        ns <- NS(id) # in case we create inputs, e.g. via renderUI
        module <- 'normalizeBatch' # for reportProgress tracing
#----------------------------------------------------------------------

#----------------------------------------------------------------------
# initialize module
#----------------------------------------------------------------------
sampleSet <- sampleSetServer( # selectors to pick a sample set
    id = 'sampleSet',
    parentId = id
)
stepper <- listStepperButtonsServer( # inputs to pick a single sample or cell from the sample set
    id = 'stepper',
    dataReactive = sampleSet$assignments,
    nameFn = getAssignedSampleName
)
libraryQCFailed <- getStepOutcomesByType('libraryQC')
gcBiasOutcomes  <- getStepOutcomesByType('normalizeGC')

#----------------------------------------------------------------------
# cascade from selected sampleSet to its associated sources (named by Project)
#----------------------------------------------------------------------
observeEvent(sampleSet$assignments(), {
    ssa <- sampleSet$assignments()
    req(ssa)
    sourceIds <- ssa[, Source_ID]
    names(sourceIds) <- getSourceFilePackageName(sourceIds)
    updateSelectInput(session, 'sourceId', choices = sourceIds) 
})
sourceInfo <- reactive({
    sourceId <- input$sourceId
    sampleId <- stepper$getCurrent()$Sample_ID
    req(sourceId)
    req(sampleId)
    list(
        sourceId = sourceId,
        sampleId = sampleId,
        failed   = libraryQCFailed()[[sourceId]][sampleId],
        rejected = gcBias()$batchReject_s[[sampleId]] >= CONSTANTS$rejected
    ) 
})

#----------------------------------------------------------------------
# react to sample/source selectors by collecting data from GC bias normalization
#----------------------------------------------------------------------
mse <- reactive({ # mse = mdiSummarizedExperiment, a version of RangedSummarizedExperiment
    getGcBiasMse(module, options, input$sourceId,
                 sampleIds = sampleSet$assignments()$Sample_ID)
})
gcBias <- reactive({
    getGcBiasOutcomes(mse)
})

#----------------------------------------------------------------------
# cascade to initialize, or retrieve, the batch effect normalization static object
#----------------------------------------------------------------------
# initialize the additional layers generated by batch effect normalization
# keyed as a MSE + a specific subset of samples
createBatchEffectList <- function(keyObject, mse, gcBias, sampleIds, ...){ #, Parameters
    reportProgress('createBatchEffectList', module)
    mse <- mse$value

    # identify the good samples that have propagated forward in a specific sampleSet
    allSampleIds     <- names(gcBias$MCN_s) # all samples in the source
    unfailedSamples  <- sapply(gcBias$fit, is.list)
    batchedSampleJs  <- which(gcBias$batchReject_s == CONSTANTS$batched & unfailedSamples)
    batchedSampleIds <- allSampleIds[batchedSampleJs]
    batchedSampleIds <- batchedSampleIds[batchedSampleIds %in% sampleIds]
    goodSampleJs     <- which(gcBias$batchReject_s < CONSTANTS$rejected & unfailedSamples)
    goodSampleIds    <- allSampleIds[goodSampleJs]
    goodSampleIds    <- goodSampleIds[goodSampleIds %in% sampleIds]
    
    # calculate the percentile of each bin in each sample relative to its nbinom GC fit
    # use all non-rejected samples, but only the bins assigned a copy number by user
    x <- list()
    gc_b <- getCol(mse, 'gc_b_ma')
    x$lowertail <- as.data.table( lapply(goodSampleIds, function(sampleId){ 
        cumprob(
            gcBias$fit[[sampleId]],
            binCounts = getCol(mse, sampleId, 'NR_map_b'),
            fractionGC = gc_b,
            binCN = inverse.rle( gcBias$hmm[[sampleId]] )
            #binCN = inverse.rle( gcBias$CN_b[[sampleId]] )
        ) 
    }) )
    setnames(x$lowertail, goodSampleIds)

    # calculate the median percentile for each from among the bins and samples declared to be trustworthy
    x$lowertail$median <- apply(x$lowertail[, .SD, .SDcols = batchedSampleIds], 1, median, na.rm = TRUE)

    ## more complex method: allow samples to vary in how much batch correction is applied
    ## in testing, yields less powerful correction
    #m <- x$lowertail$median
    #mdf <- data.frame(x=m, x2=m^2, x3=m^3)
    #x$fit <- as.data.table( lapply(goodSampleIds, function(sampleId){
    #    fit <- fitTrendline(data.table(x=m, y=x$lowertail[[sampleId]]), 'cubic')
    #    predict(fit, mdf)
    #}) )
    #setnames(x$fit, goodSampleIds)
    #x$readPerAllele_peak <- as.data.table( lapply(goodSampleIds, function(sampleId){
    #    gcFit <- gcBias$fit[[sampleId]]
    #    rpa <- predict(gcFit, fractionGC=gc_b, type='peak')
    #    theta <- gcFit$theta
    #    excess <- qnbinom(x$fit[[sampleId]], size=theta, mu=rpa) -
    #              qnbinom(0.5,               size=theta, mu=rpa)        
    #    rpa + excess
    #}) )
    #setnames(x$readPerAllele_peak, goodSampleIds)
    
    # simpler method: just use the median percentile for each bin to establish the correction
    x$readPerAllele_peak <- as.data.table( lapply(goodSampleIds, function(sampleId){
        gcFit <- gcBias$fit[[sampleId]]
        rpa <- predict(gcFit, fractionGC = gc_b, type = 'adjustedPeak')
        theta <- gcFit$theta
        
        # this and method below are very nearly equivalent...
        #qnbinom(x$lowertail$median, size=theta, mu=rpa)
        
        excess <- qnbinom(x$lowertail$median, size = theta, mu = rpa) -
                  qnbinom(0.5,                size = theta, mu = rpa)        
        rpa + excess # thus, expect more reads for bins with consistently high nbinom percentile
    }) )
    setnames(x$readPerAllele_peak, goodSampleIds)
    
    # return the result
    x$sampleIds <- goodSampleIds
    x
}
batchEffects <- reactive({
    getBatchEffects(module, options,
                    mse(), gcBias(), sampleSet$assignments()$Sample_ID, 
                    createFn = createBatchEffectList, create = "asNeeded")$value
})

#----------------------------------------------------------------------
# create the key for cached plots
#----------------------------------------------------------------------
plotCacheKey <- reactive({
    list(
        batchEffectsKey = batchEffects()$key,
        sampleId = stepper$getCurrent()$Sample_ID
    )
})

#----------------------------------------------------------------------
# show failed sample feedback
#----------------------------------------------------------------------
failedQCText <- reactive({
    sourceInfo <- sourceInfo()
    req(sourceInfo)
    if(sourceInfo$failed) "Failed Library QC"
    else if (sourceInfo$rejected) "Rejected at GC Bias normalization"
    else NULL
}) 
output$failedQC <- renderText({ failedQCText() })

#----------------------------------------------------------------------
# plot results by genomic bin
#----------------------------------------------------------------------
getChromLines <- function(d){
    L <- d$x[ getCol(mse()$value, 'isLastBin') ]
    structure(c(0, L) + 0.5, color = rep('grey', length(L) + 1))    
}
getCNLines <- function(...){
    sampleId <- stepper$getCurrent()$Sample_ID
    structure(gcBias()$MCN_s[[sampleId]] + -2:2,
              color = c('grey', 'grey', 'black', 'grey', 'grey'))   
}
readDepthPlotData_ <- function(type){
    sourceInfo <- sourceInfo()
    req(sourceInfo)
    req(!sourceInfo$failed && !sourceInfo$rejected)
    batchEffects <- batchEffects()
    req(batchEffects)
    sampleId <- stepper$getCurrent()$Sample_ID
    rpa <- if(type == 'gcBiasFit'){
        gc_b <- getCol(mse()$value, 'gc_b_ma')
        predict(gcBias()$fit[[sampleId]], fractionGC = gc_b, type = 'peak')
    } else {
        if(!(sampleId %in% batchEffects$sampleIds)) return(NULL)
        batchEffects$readPerAllele_peak[[sampleId]]
    }
    d <- getXY(mse()$value,
        xcol = 'binN',
        ycol = sampleId,
        assay = 'NR_map_b'
    )
    d$y <- d$y / rpa
    d
}
readDepthPlot_ <- function(id, data){
    interactiveScatterplotServer(
        id,
        data,
        accelerate = TRUE,
        xtitle = "Genomic Bin",
        xrange = range_pad,
        xzeroline = FALSE,
        ytitle = "Copy Number",
        grid = list(x = FALSE, y = FALSE),
        vLines = getChromLines,
        hLines = getCNLines,
        yrange = c(0, 5),
        cacheReactive = plotCacheKey
    )
}
gcCorrectedDepthPlotData <- reactive({ readDepthPlotData_('gcBiasFit') })
beCorrectedDepthPlotData <- reactive({ readDepthPlotData_('batchEffectFit') })
gcCorrectedDepthPlot <- readDepthPlot_('gcCorrectedDepthPlot', gcCorrectedDepthPlotData)
beCorrectedDepthPlot <- readDepthPlot_('beCorrectedDepthPlot', beCorrectedDepthPlotData)

#----------------------------------------------------------------------
# QC plot: distribution of CN_gc from user-selected bins before and after batch effect normalization
#----------------------------------------------------------------------
readDepthDensityPlotData_ <- function(plotData){
    sourceInfo <- sourceInfo()
    req(sourceInfo)
    req(!sourceInfo$failed && !sourceInfo$rejected)
    gcBias <- gcBias()
    req(gcBias)
    batchEffects <- batchEffects()
    req(batchEffects)
    rd <- plotData()
    req(rd)
    sampleId <- stepper$getCurrent()$Sample_ID
    if(!(sampleId %in% batchEffects$sampleIds)) return(NULL)
    MCN_b <- inverse.rle(gcBias$CN_b[[sampleId]]) == gcBias$MCN_s[[sampleId]]
    d <- density(na.omit(rd$y[MCN_b]))
    data.table(x = d$x, y = d$y)
}
readDepthDensityPlotData_gc <- reactive({
    readDepthDensityPlotData_(gcCorrectedDepthPlotData)
})
readDepthDensityPlotData_be <- reactive({
    readDepthDensityPlotData_(beCorrectedDepthPlotData)
})
interactiveScatterplotServer(
    'readDepthDensityPlot',
    readDepthDensityPlotData_be, 
    xtitle = "Copy Number",
    ytitle = "Density",
    xrange = c(0, 5),
    yrange = range_pad,
    grid = list(x = FALSE, y = TRUE),
    vLines = getCNLines,
    mode = 'lines',
    lineWidth = 2,
    overplot = readDepthDensityPlotData_gc,
    cacheReactive = plotCacheKey
)

#----------------------------------------------------------------------
# QC plot: sample vs. median 
#----------------------------------------------------------------------
sampleVsMedianData <- reactive({
    batchEffects <- batchEffects()
    req(batchEffects)
    sampleId <- stepper$getCurrent()$Sample_ID  
    data.table(
        x = batchEffects$lowertail$median,
        y = batchEffects$lowertail[[sampleId]]
    )
})
sampleVsMedian <- interactiveScatterplotServer(
    'sampleVsMedian',
    sampleVsMedianData,
    accelerate = TRUE,
    xtitle = 'Median(lowertail)',
    ytitle = "lowertail",
    xrange = c(0, 1),
    yrange = c(0, 1),
    fitMethod = 'cubic',
    hLines = structure(0.5, color = 'black'),
    vLines = structure(0.5, color = 'black'),
    unityLine = TRUE,
    cacheReactive = plotCacheKey
)

#----------------------------------------------------------------------
# define bookmarking actions
#----------------------------------------------------------------------
observe({
    bm <- getModuleBookmark(id, module, bookmark, locks)
    req(bm)
    playbackStepBookmark(id, module, session, bookmark, handlers = list(
        'stepper-current' = stepper$overrideDefault
    ))
})

#----------------------------------------------------------------------
# set return values as reactives that will be assigned to app$data[[stepName]]
#----------------------------------------------------------------------
list(
    input = input, # inputs to be bookmarked as declared by boomarkedInput() wrapper  
    isReady  = reactive({ getStepReadiness(options$source) })
)

#----------------------------------------------------------------------
# END MODULE SERVER
#----------------------------------------------------------------------
})}
#----------------------------------------------------------------------
